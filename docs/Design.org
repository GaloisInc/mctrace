* Design

The mctrace system is an implementation of DTrace for machine code.  This document describes the high-level design of the system. The tool is implemented as a core library implementing all of the required services (see below) and a thin tool presenting a command line interface.  This command line tool, ~mctrace~, is designed to be a useful standalone application in its own right. It is also intended to be the case that the core can be customized to particular use scenarios (e.g., with more specialized trace points or storage providers) and reconstituted into other tools.

The tool behaves much like DTrace, but does not require any kernel support or any recompilation of the program to be traced. It takes the same tracing specifications (D language programs) and uses binary rewriting to insert probes into binaries.

The system core is divided into three main components:
1. The storage provider (which stores trace information)
2. Code generation for DTrace scripts
3. Instrumentation insertion via binary rewriting

* Storage Provider API

This API provides services for storing information generated by probes.  This can include fixed-size storage for counters and aggregates, as well as unbounded storage for textual output.

- The fixed-size storage (global variables and aggregates) will be stored into a memory-mapped file in a binary format
- The variable-size storage will have multiple backends

Note that all of the storage backends are designed to be modular so that they can be replaced. This is critical, for example, for bare metal systems that do not provide the same set of OS services as desktop/server class operating systems. In those cases, traces may need to be aggregated in memory and periodically persisted via bus-based communication.

* Code Generation

The tool takes tracing specifications in the same format as DTrace: scripts written in the DTrace language (called D).  The tool includes a parser for these scripts.  It then generates position-independent code for supported platforms using LLVM.

Note: it may be more prudent to generate simple C and then invoke a user-provided compiler.

* Binary Rewriting


* Challenges

** Dynamically linked binaries
Instrumenting the shared libraries is difficult (not practical to automate). We could add an LD_PRELOAD shim to capture some things.
